<?php

namespace App\Services\Scm;

use Illuminate\Support\Facades\DB;
use Carbon\Carbon;
use Exception;

class ScmRevisionService
{
    protected $ledgerService;

    public function __construct(ScmLedgerService $ledgerService)
    {
        $this->ledgerService = $ledgerService;
    }

    /**
     * Process Stock Revision (Adjustment)
     * 
     * @param int $whSeq Warehouse Sequence
     * @param array $items Array of ['goods_seq', 'option_seq', 'ea', 'reason']
     * @param string|null $adminMemo
     * @return int Created Revision Sequence (rev_seq)
     */
    public function processRevision(int $whSeq, array $items, ?string $adminMemo = '')
    {
        return DB::transaction(function () use ($whSeq, $items, $adminMemo) {
            // 1. Generate Code
            $revSeq = DB::table('fm_scm_stock_revision')->max('revision_seq') + 1;
            $revCode = 'REV' . date('YmdHis') . $revSeq;

            // 2. Create Header
            $revSeq = DB::table('fm_scm_stock_revision')->insertGetId([
                'revision_code' => $revCode,
                'wh_seq' => $whSeq,
                'regist_date' => Carbon::now(),
                'admin_memo' => $adminMemo,
                'revision_type' => 'calc', // Manual Calculation
                'revision_status' => '1',
                'chg_log' => 'Auto-generated by SCM Migration',
            ]);

            $ledgerTargets = [];
            $totalEa = 0;

            foreach ($items as $item) {
                // Fetch current stock for snapshot (but don't store in details)
                $curEa = (int)$item['ea']; // Signed

                // 3. Create Details
                // Only storing EA and basic info. No prev_stock column.
                DB::table('fm_scm_stock_revision_goods')->insert([
                    'revision_seq' => $revSeq,
                    'goods_seq' => $item['goods_seq'],
                    'option_seq' => $item['option_seq'],
                    'option_type' => $item['option_type'] ?? 'option',
                    'ea' => $curEa,
                    'goods_name' => '', // TODO: fetch
                    'option_name' => '', // TODO: fetch
                    // Prices required by schema? Assuming nullable or 0 default.
                    'supply_price' => 0,
                    'krw_supply_price' => 0,
                ]);

                // 4. Update Stock
                if ($curEa > 0) {
                    DB::table('fm_goods_supply')
                        ->where('goods_seq', $item['goods_seq'])
                        ->where('option_seq', $item['option_seq'])
                        ->increment('stock', $curEa);
                    
                    DB::table('fm_goods_supply')
                        ->where('goods_seq', $item['goods_seq'])
                        ->where('option_seq', $item['option_seq'])
                        ->increment('total_stock', $curEa);
                } elseif ($curEa < 0) {
                    DB::table('fm_goods_supply')
                        ->where('goods_seq', $item['goods_seq'])
                        ->where('option_seq', $item['option_seq'])
                        ->decrement('stock', abs($curEa));

                     DB::table('fm_goods_supply')
                        ->where('goods_seq', $item['goods_seq'])
                        ->where('option_seq', $item['option_seq'])
                        ->decrement('total_stock', abs($curEa));
                }

                // Prepare for ledger
                $ledgerTargets[] = [
                    'goods_seq' => $item['goods_seq'],
                    'option_seq' => $item['option_seq'],
                    'option_type' => $item['option_type'] ?? 'option'
                ];

                $totalEa += $curEa;
            }

            // Update Header Total (Optional usage, some legacy systems track net change)
            // DB::table('fm_scm_revision')->where('rev_seq', $revSeq)->update(['total_ea' => $totalEa]);

            // 5. Update Stock Ledger
            if (!empty($ledgerTargets)) {
                $this->ledgerService->updateDailyLedger($whSeq, $ledgerTargets);
            }

            return $revSeq;
        });
    }

    /**
     * Import Revision Excel
     * Expected Columns: A:SystemConfirmCode, B:GoodsCode, C:TargetStockQty
     */
    public function importRevisionExcel($file, int $whSeq = 1)
    {
        // Simple array import
        $rows = \Maatwebsite\Excel\Facades\Excel::toArray(new \stdClass, $file);
        $sheet = $rows[0] ?? [];
        
        // Remove Header if necessary (Legacy code didn't seem to skip, checks for valid goods code)
        // But usually row 1 is header. Let's assume row 1 is header if it contains non-numeric in C?
        // Legacy loop started from row 1 (1-indexed in PHPExcel usually implies skipping header if manual, or just checking).
        // Let's iterate all and skip invalid.

        $items = [];
        $processedCount = 0;

        foreach ($sheet as $index => $row) {
            // A: scode, B: code, C: ea
            $scode = $row[0] ?? null;
            $code = $row[1] ?? null;
            $targetEa = $row[2] ?? null;

            if (!$code || !is_numeric($targetEa)) continue;

            // Find Goods
            // Legacy matches both code and scode.
            $goods = DB::table('fm_goods')
                ->join('fm_goods_supply', 'fm_goods.goods_seq', '=', 'fm_goods_supply.goods_seq')
                ->where('fm_goods.goods_code', $code)
                // ->where('fm_goods.goods_scode', $scode) // Optional validation? Legacy did strict check.
                ->select('fm_goods.goods_seq', 'fm_goods_supply.stock', 'fm_goods_supply.option_seq')
                ->first();

            if ($goods) {
                // Determine Option Seq (Default option usually)
                // If the excel doesn't specify option, we assume default option of the goods?
                // Legacy query: left join fm_goods_option ... where g.goods_code = ... limit 1.
                // It picked the FIRST option found.
                
                // My query above joins supply directly (1:1 usually for simple goods). 
                // For complex goods, goods_code might be shared or strictly unique.
                // Let's use the legacy logic: find specific option if possible, else first.
                
                $option = DB::table('fm_goods_option')
                    ->where('goods_seq', $goods->goods_seq)
                    ->orderBy('default_option', 'desc') // Prefer default
                    ->first();

                if ($option) {
                    $optSeq = $option->option_seq;
                    
                    // Get Warehouse Specific Stock if wh_seq > 0
                    // But legacy calculated delta against `fm_goods_supply.stock` (Global Stock?).
                    // Line 190: $o_ea = $ea - $GD['0']['stock'];
                    // Line 184 query selects `fs.stock`. `fm_goods_supply`.
                    // This implies legacy Revision Excel adjusts GLOBAL stock, but assigns it to WH 1.
                    // If I am in a specific WH mode, I should probably diff against THAT WH's stock?
                    
                    // However, to strictly follow legacy:
                    // It calculated against `fs.stock` (Total Supply Stock).
                    // I will calculate against the target Warehouse Stock if possible, or Total if WH is generic.
                    // Actually, for correctness, "Revision" should adjust the stock in the *target warehouse*.
                    // So I should fetch current stock in `whSeq`.
                    
                    $currentWhStock = DB::table('fm_scm_location_link')
                        ->where('goods_seq', $goods->goods_seq)
                        ->where('wh_seq', $whSeq)
                        ->sum('ea');

                    $diff = $targetEa - $currentWhStock;

                    if ($diff != 0) {
                        $items[] = [
                            'goods_seq' => $goods->goods_seq,
                            'option_seq' => $optSeq,
                            'option_type' => $option->option_type,
                            'ea' => $diff,
                            'reason' => 'Excel Upload Adjustment'
                        ];
                        $processedCount++;
                    }
                }
            }
        }

        if ($processedCount > 0) {
            $this->processRevision($whSeq, $items, 'Excel Upload Batch');
        }

        return $processedCount;
    }

    public function downloadExcelSample()
    {
        $filename = 'stock_revision_sample.csv';
        $headers = [
            "Content-type" => "text/csv",
            "Content-Disposition" => "attachment; filename=$filename",
            "Pragma" => "no-cache"
        ];
        
        return response()->stream(function() {
            $file = fopen('php://output', 'w');
            fputcsv($file, ['SystemCode', 'GoodsCode', 'TargetQty(Absolute)']);
            fputcsv($file, ['SCODE123', 'GCODE001', '100']);
            fputcsv($file, ['SCODE456', 'GCODE002', '50']);
            fclose($file);
        }, 200, $headers);
    }
}
